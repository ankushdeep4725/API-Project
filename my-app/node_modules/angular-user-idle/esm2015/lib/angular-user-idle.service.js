/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Injectable, Optional } from '@angular/core';
import { Subject, merge, fromEvent, from, interval, timer, of } from 'rxjs';
import { bufferTime, distinctUntilChanged, filter, finalize, map, scan, switchMap, take, takeUntil, tap } from 'rxjs/operators';
import { UserIdleConfig } from './angular-user-idle.config';
import * as i0 from "@angular/core";
import * as i1 from "./angular-user-idle.config";
/**
 * User's idle service.
 */
export class UserIdleService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.timerStart$ = new Subject();
        this.timeout$ = new Subject();
        /**
         * Idle value in seconds.
         * Default equals to 10 minutes.
         */
        this.idle = 600;
        /**
         * Timeout value in seconds.
         * Default equals to 5 minutes.
         */
        this.timeout = 300;
        /**
         * Ping value in seconds.
         * * Default equals to 2 minutes.
         */
        this.ping = 120;
        if (config) {
            this.idle = config.idle;
            this.timeout = config.timeout;
            this.ping = config.ping;
        }
        this.activityEvents$ = merge(fromEvent(window, 'mousemove'), fromEvent(window, 'resize'), fromEvent(document, 'keydown'));
        this.idle$ = from(this.activityEvents$);
    }
    /**
     * Start watching for user idle and setup timer and ping.
     * @return {?}
     */
    startWatching() {
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
        // If any of user events is not active for idle-seconds when start timer.
        this.idleSubscription = this.idle$
            .pipe(bufferTime(5000), // Starting point of detecting of user's inactivity
        // Starting point of detecting of user's inactivity
        filter(arr => !arr.length && !this.isInactivityTimer), tap(() => this.isInactivityTimer = true), switchMap(() => interval(1000).pipe(takeUntil(merge(this.activityEvents$, timer(this.idle * 1000).pipe(tap(() => this.timerStart$.next(true))))), finalize(() => (this.isInactivityTimer = false)))))
            .subscribe();
        this.setupTimer(this.timeout);
        this.setupPing(this.ping);
    }
    /**
     * @return {?}
     */
    stopWatching() {
        this.stopTimer();
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    stopTimer() {
        this.timerStart$.next(false);
    }
    /**
     * @return {?}
     */
    resetTimer() {
        this.stopTimer();
        this.isTimeout = false;
    }
    /**
     * Return observable for timer's countdown number that emits after idle.
     * @return {?}
     */
    onTimerStart() {
        return this.timerStart$.pipe(distinctUntilChanged(), switchMap(start => (start ? this.timer$ : of(null))));
    }
    /**
     * Return observable for timeout is fired.
     * @return {?}
     */
    onTimeout() {
        return this.timeout$.pipe(filter(timeout => !!timeout), tap(() => this.isTimeout = true), map(() => true));
    }
    /**
     * @return {?}
     */
    getConfigValue() {
        return {
            idle: this.idle,
            timeout: this.timeout,
            ping: this.ping
        };
    }
    /**
     * Set config values.
     * @param {?} config
     * @return {?}
     */
    setConfigValues(config) {
        if (this.idleSubscription && !this.idleSubscription.closed) {
            console.error('Call stopWatching() before set config values');
            return;
        }
        if (config.idle) {
            this.idle = config.idle;
        }
        if (config.ping) {
            this.ping = config.ping;
        }
        if (config.timeout) {
            this.timeout = config.timeout;
        }
    }
    /**
     * Setup timer.
     *
     * Counts every seconds and return n+1 and fire timeout for last count.
     * @param {?} timeout Timeout in seconds.
     * @return {?}
     */
    setupTimer(timeout) {
        this.timer$ = interval(1000).pipe(take(timeout), map(() => 1), scan((acc, n) => acc + n), tap(count => {
            if (count === timeout) {
                this.timeout$.next(true);
            }
        }));
    }
    /**
     * Setup ping.
     *
     * Pings every ping-seconds only if is not timeout.
     * @param {?} ping
     * @return {?}
     */
    setupPing(ping) {
        this.ping$ = interval(ping * 1000).pipe(filter(() => !this.isTimeout));
    }
}
UserIdleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
];
/** @nocollapse */
UserIdleService.ctorParameters = () => [
    { type: UserIdleConfig, decorators: [{ type: Optional },] },
];
/** @nocollapse */ UserIdleService.ngInjectableDef = i0.defineInjectable({ factory: function UserIdleService_Factory() { return new UserIdleService(i0.inject(i1.UserIdleConfig, 8)); }, token: UserIdleService, providedIn: "root" });
function UserIdleService_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    UserIdleService.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    UserIdleService.ctorParameters;
    /** @type {?} */
    UserIdleService.prototype.ping$;
    /**
     * Events that can interrupts user's inactivity timer.
     * @type {?}
     */
    UserIdleService.prototype.activityEvents$;
    /** @type {?} */
    UserIdleService.prototype.timerStart$;
    /** @type {?} */
    UserIdleService.prototype.timeout$;
    /** @type {?} */
    UserIdleService.prototype.idle$;
    /** @type {?} */
    UserIdleService.prototype.timer$;
    /**
     * Idle value in seconds.
     * Default equals to 10 minutes.
     * @type {?}
     */
    UserIdleService.prototype.idle;
    /**
     * Timeout value in seconds.
     * Default equals to 5 minutes.
     * @type {?}
     */
    UserIdleService.prototype.timeout;
    /**
     * Ping value in seconds.
     * * Default equals to 2 minutes.
     * @type {?}
     */
    UserIdleService.prototype.ping;
    /**
     * Timeout status.
     * @type {?}
     */
    UserIdleService.prototype.isTimeout;
    /**
     * Timer of user's inactivity is in progress.
     * @type {?}
     */
    UserIdleService.prototype.isInactivityTimer;
    /** @type {?} */
    UserIdleService.prototype.idleSubscription;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci11c2VyLWlkbGUuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItdXNlci1pZGxlLyIsInNvdXJjZXMiOlsibGliL2FuZ3VsYXItdXNlci1pZGxlLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ3JELE9BQU8sRUFFTCxPQUFPLEVBRVAsS0FBSyxFQUNMLFNBQVMsRUFDVCxJQUFJLEVBQ0osUUFBUSxFQUNSLEtBQUssRUFDTCxFQUFFLEVBQ0gsTUFBTSxNQUFNLENBQUM7QUFDZCxPQUFPLEVBQ0wsVUFBVSxFQUNWLG9CQUFvQixFQUNwQixNQUFNLEVBQ04sUUFBUSxFQUNSLEdBQUcsRUFDSCxJQUFJLEVBQ0osU0FBUyxFQUNULElBQUksRUFDSixTQUFTLEVBQ1QsR0FBRyxFQUNKLE1BQU0sZ0JBQWdCLENBQUM7QUFDeEIsT0FBTyxFQUFFLGNBQWMsRUFBRSxNQUFNLDRCQUE0QixDQUFDOzs7Ozs7QUFRNUQsTUFBTTs7OztJQXNDSixZQUF3QjsyQkE5QkEsSUFBSSxPQUFPLEVBQVc7d0JBQ3pCLElBQUksT0FBTyxFQUFXOzs7OztvQkFPMUIsR0FBRzs7Ozs7dUJBS0EsR0FBRzs7Ozs7b0JBS04sR0FBRztRQWFsQixFQUFFLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO1lBQ1gsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQztZQUM5QixJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7U0FDekI7UUFFRCxJQUFJLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FDMUIsU0FBUyxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsRUFDOUIsU0FBUyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMs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QVMsQ0FBQyxJQUFZO1FBQzlCLElBQUksQ0FBQyxLQUFLLEdBQUcsUUFBUSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQ3JDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FDOUIsQ0FBQztLQUNIOzs7WUF6TEYsVUFBVSxTQUFDO2dCQUNWLFVBQVUsRUFBRSxNQUFNO2FBQ25COzs7O1lBUFEsY0FBYyx1QkE4Q1IsUUFBUSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUsIE9wdGlvbmFsIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBPYnNlcnZhYmxlLFxuICBTdWJqZWN0LFxuICBTdWJzY3JpcHRpb24sXG4gIG1lcmdlLFxuICBmcm9tRXZlbnQsXG4gIGZyb20sXG4gIGludGVydmFsLFxuICB0aW1lcixcbiAgb2Zcbn0gZnJvbSAncnhqcyc7XG5pbXBvcnQge1xuICBidWZmZXJUaW1lLFxuICBkaXN0aW5jdFVudGlsQ2hhbmdlZCxcbiAgZmlsdGVyLFxuICBmaW5hbGl6ZSxcbiAgbWFwLFxuICBzY2FuLFxuICBzd2l0Y2hNYXAsXG4gIHRha2UsXG4gIHRha2VVbnRpbCxcbiAgdGFwXG59IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFVzZXJJZGxlQ29uZmlnIH0gZnJvbSAnLi9hbmd1bGFyLXVzZXItaWRsZS5jb25maWcnO1xuXG4vKipcbiAqIFVzZXIncyBpZGxlIHNlcnZpY2UuXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFVzZXJJZGxlU2VydmljZSB7XG4gIHBpbmckOiBPYnNlcnZhYmxlPGFueT47XG5cbiAgLyoqXG4gICAqIEV2ZW50cyB0aGF0IGNhbiBpbnRlcnJ1cHRzIHVzZXIncyBpbmFjdGl2aXR5IHRpbWVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFjdGl2aXR5RXZlbnRzJDogT2JzZXJ2YWJsZTxhbnk+O1xuXG4gIHByb3RlY3RlZCB0aW1lclN0YXJ0JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIHByb3RlY3RlZCB0aW1lb3V0JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG4gIHByb3RlY3RlZCBpZGxlJDogT2JzZXJ2YWJsZTxhbnk+O1xuICBwcm90ZWN0ZWQgdGltZXIkOiBPYnNlcnZhYmxlPGFueT47XG4gIC8qKlxuICAgKiBJZGxlIHZhbHVlIGluIHNlY29uZHMuXG4gICAqIERlZmF1bHQgZXF1YWxzIHRvIDEwIG1pbnV0ZXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgaWRsZSA9IDYwMDtcbiAgLyoqXG4gICAqIFRpbWVvdXQgdmFsdWUgaW4gc2Vjb25kcy5cbiAgICogRGVmYXVsdCBlcXVhbHMgdG8gNSBtaW51dGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIHRpbWVvdXQgPSAzMDA7XG4gIC8qKlxuICAgKiBQaW5nIHZhbHVlIGluIHNlY29uZHMuXG4gICAqICogRGVmYXVsdCBlcXVhbHMgdG8gMiBtaW51dGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIHBpbmcgPSAxMjA7XG4gIC8qKlxuICAgKiBUaW1lb3V0IHN0YXR1cy5cbiAgICovXG4gIHByb3RlY3RlZCBpc1RpbWVvdXQ6IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUaW1lciBvZiB1c2VyJ3MgaW5hY3Rpdml0eSBpcyBpbiBwcm9ncmVzcy5cbiAgICovXG4gIHByb3RlY3RlZCBpc0luYWN0aXZpdHlUaW1lcjogYm9vbGVhbjtcblxuICBwcm90ZWN0ZWQgaWRsZVN1YnNjcmlwdGlvbjogU3Vic2NyaXB0aW9uO1xuXG4gIGNvbnN0cnVjdG9yKEBPcHRpb25hbCgpIGNvbmZpZzogVXNlcklkbGVDb25maWcpIHtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICB0aGlzLmlkbGUgPSBjb25maWcuaWRsZTtcbiAgICAgIHRoaXMudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuICAgICAgdGhpcy5waW5nID0gY29uZmlnLnBpbmc7XG4gICAgfVxuXG4gICAgdGhpcy5hY3Rpdml0eUV2ZW50cyQgPSBtZXJnZShcbiAgICAgIGZyb21FdmVudCh3aW5kb3csICdtb3VzZW1vdmUnKSxcbiAgICAgIGZyb21FdmVudCh3aW5kb3csICdyZXNpemUnKSxcbiAgICAgIGZyb21FdmVudChkb2N1bWVudCwgJ2tleWRvd24nKVxuICAgICk7XG5cbiAgICB0aGlzLmlkbGUkID0gZnJvbSh0aGlzLmFjdGl2aXR5RXZlbnRzJCk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgd2F0Y2hpbmcgZm9yIHVzZXIgaWRsZSBhbmQgc2V0dXAgdGltZXIgYW5kIHBpbmcuXG4gICAqL1xuICBzdGFydFdhdGNoaW5nKCkge1xuICAgIGlmICh0aGlzLmlkbGVTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuaWRsZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cblxuICAgIC8vIElmIGFueSBvZiB1c2VyIGV2ZW50cyBpcyBub3QgYWN0aXZlIGZvciBpZGxlLXNlY29uZHMgd2hlbiBzdGFydCB0aW1lci5cbiAgICB0aGlzLmlkbGVTdWJzY3JpcHRpb24gPSB0aGlzLmlkbGUkXG4gICAgICAucGlwZShcbiAgICAgICAgYnVmZmVyVGltZSg1MDAwKSwgLy8gU3RhcnRpbmcgcG9pbnQgb2YgZGV0ZWN0aW5nIG9mIHVzZXIncyBpbmFjdGl2aXR5XG4gICAgICAgIGZpbHRlcihhcnIgPT4gIWFyci5sZW5ndGggJiYgIXRoaXMuaXNJbmFjdGl2aXR5VGltZXIpLFxuICAgICAgICB0YXAoKCkgPT4gdGhpcy5pc0luYWN0aXZpdHlUaW1lciA9IHRydWUpLFxuICAgICAgICBzd2l0Y2hNYXAoKCkgPT4gaW50ZXJ2YWwoMTAwMCkucGlwZShcbiAgICAgICAgICB0YWtlVW50aWwoXG4gICAgICAgICAgICBtZXJnZShcbiAgICAgICAgICAgICAgdGhpcy5hY3Rpdml0eUV2ZW50cyQsXG4gICAgICAgICAgICAgIHRpbWVyKHRoaXMuaWRsZSAqIDEwMDApLnBpcGUoXG4gICAgICAgICAgICAgICAgdGFwKCgpID0+IHRoaXMudGltZXJTdGFydCQubmV4dCh0cnVlKSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICksXG4gICAgICAgICAgZmluYWxpemUoKCkgPT4gKHRoaXMuaXNJbmFjdGl2aXR5VGltZXIgPSBmYWxzZSkpXG4gICAgICAgICAgKVxuICAgICAgICApXG4gICAgICApXG4gICAgICAuc3Vic2NyaWJlKCk7XG5cbiAgICB0aGlzLnNldHVwVGltZXIodGhpcy50aW1lb3V0KTtcbiAgICB0aGlzLnNldHVwUGluZyh0aGlzLnBpbmcpO1xuICB9XG5cbiAgc3RvcFdhdGNoaW5nKCkge1xuICAgIHRoaXMuc3RvcFRpbWVyKCk7XG4gICAgaWYgKHRoaXMuaWRsZVN1YnNjcmlwdGlvbikge1xuICAgICAgdGhpcy5pZGxlU3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICB9XG5cbiAgc3RvcFRpbWVyKCkge1xuICAgIHRoaXMudGltZXJTdGFydCQubmV4dChmYWxzZSk7XG4gIH1cblxuICByZXNldFRpbWVyKCkge1xuICAgIHRoaXMuc3RvcFRpbWVyKCk7XG4gICAgdGhpcy5pc1RpbWVvdXQgPSBmYWxzZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gb2JzZXJ2YWJsZSBmb3IgdGltZXIncyBjb3VudGRvd24gbnVtYmVyIHRoYXQgZW1pdHMgYWZ0ZXIgaWRsZS5cbiAgICovXG4gIG9uVGltZXJTdGFydCgpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xuICAgIHJldHVybiB0aGlzLnRpbWVyU3RhcnQkLnBpcGUoXG4gICAgICBkaXN0aW5jdFVudGlsQ2hhbmdlZCgpLFxuICAgICAgc3dpdGNoTWFwKHN0YXJ0ID0+IChzdGFydCA/IHRoaXMudGltZXIkIDogb2YobnVsbCkpKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIG9ic2VydmFibGUgZm9yIHRpbWVvdXQgaXMgZmlyZWQuXG4gICAqL1xuICBvblRpbWVvdXQoKTogT2JzZXJ2YWJsZTxib29sZWFuPiB7XG4gICAgcmV0dXJuIHRoaXMudGltZW91dCQucGlwZShcbiAgICAgIGZpbHRlcih0aW1lb3V0ID0+ICEhdGltZW91dCksXG4gICAgICB0YXAoKCkgPT4gdGhpcy5pc1RpbWVvdXQgPSB0cnVlKSxcbiAgICAgIG1hcCgoKSA9PiB0cnVlKVxuICAgICk7XG4gIH1cblxuICBnZXRDb25maWdWYWx1ZSgpOiBVc2VySWRsZUNvbmZpZyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkbGU6IHRoaXMuaWRsZSxcbiAgICAgIHRpbWVvdXQ6IHRoaXMudGltZW91dCxcbiAgICAgIHBpbmc6IHRoaXMucGluZ1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogU2V0IGNvbmZpZyB2YWx1ZXMuXG4gICAqIEBwYXJhbSBjb25maWdcbiAgICovXG4gIHNldENvbmZpZ1ZhbHVlcyhjb25maWc6IFVzZXJJZGxlQ29uZmlnKSB7XG4gICAgaWYgKHRoaXMuaWRsZVN1YnNjcmlwdGlvbiAmJiAhdGhpcy5pZGxlU3Vic2NyaXB0aW9uLmNsb3NlZCkge1xuICAgICAgY29uc29sZS5lcnJvcignQ2FsbCBzdG9wV2F0Y2hpbmcoKSBiZWZvcmUgc2V0IGNvbmZpZyB2YWx1ZXMnKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmlkbGUpIHtcbiAgICAgIHRoaXMuaWRsZSA9IGNvbmZpZy5pZGxlO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnBpbmcpIHtcbiAgICAgIHRoaXMucGluZyA9IGNvbmZpZy5waW5nO1xuICAgIH1cbiAgICBpZiAoY29uZmlnLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMudGltZW91dCA9IGNvbmZpZy50aW1lb3V0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCB0aW1lci5cbiAgICpcbiAgICogQ291bnRzIGV2ZXJ5IHNlY29uZHMgYW5kIHJldHVybiBuKzEgYW5kIGZpcmUgdGltZW91dCBmb3IgbGFzdCBjb3VudC5cbiAgICogQHBhcmFtIHRpbWVvdXQgVGltZW91dCBpbiBzZWNvbmRzLlxuICAgKi9cbiAgcHJvdGVjdGVkIHNldHVwVGltZXIodGltZW91dDogbnVtYmVyKSB7XG4gICAgdGhpcy50aW1lciQgPSBpbnRlcnZhbCgxMDAwKS5waXBlKFxuICAgICAgdGFrZSh0aW1lb3V0KSxcbiAgICAgIG1hcCgoKSA9PiAxKSxcbiAgICAgIHNjYW4oKGFjYywgbikgPT4gYWNjICsgbiksXG4gICAgICB0YXAoY291bnQgPT4ge1xuICAgICAgICBpZiAoY291bnQgPT09IHRpbWVvdXQpIHtcbiAgICAgICAgICB0aGlzLnRpbWVvdXQkLm5leHQodHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXR1cCBwaW5nLlxuICAgKlxuICAgKiBQaW5ncyBldmVyeSBwaW5nLXNlY29uZHMgb25seSBpZiBpcyBub3QgdGltZW91dC5cbiAgICogQHBhcmFtIHBpbmdcbiAgICovXG4gIHByb3RlY3RlZCBzZXR1cFBpbmcocGluZzogbnVtYmVyKSB7XG4gICAgdGhpcy5waW5nJCA9IGludGVydmFsKHBpbmcgKiAxMDAwKS5waXBlKFxuICAgICAgZmlsdGVyKCgpID0+ICF0aGlzLmlzVGltZW91dClcbiAgICApO1xuICB9XG59XG4iXX0=