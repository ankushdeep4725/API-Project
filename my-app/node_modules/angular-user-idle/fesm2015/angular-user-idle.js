import { Injectable, Optional, NgModule, defineInjectable, inject } from '@angular/core';
import { Subject, merge, fromEvent, from, interval, timer, of } from 'rxjs';
import { bufferTime, distinctUntilChanged, filter, finalize, map, scan, switchMap, take, takeUntil, tap } from 'rxjs/operators';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UserIdleConfig {
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * User's idle service.
 */
class UserIdleService {
    /**
     * @param {?} config
     */
    constructor(config) {
        this.timerStart$ = new Subject();
        this.timeout$ = new Subject();
        /**
         * Idle value in seconds.
         * Default equals to 10 minutes.
         */
        this.idle = 600;
        /**
         * Timeout value in seconds.
         * Default equals to 5 minutes.
         */
        this.timeout = 300;
        /**
         * Ping value in seconds.
         * * Default equals to 2 minutes.
         */
        this.ping = 120;
        if (config) {
            this.idle = config.idle;
            this.timeout = config.timeout;
            this.ping = config.ping;
        }
        this.activityEvents$ = merge(fromEvent(window, 'mousemove'), fromEvent(window, 'resize'), fromEvent(document, 'keydown'));
        this.idle$ = from(this.activityEvents$);
    }
    /**
     * Start watching for user idle and setup timer and ping.
     * @return {?}
     */
    startWatching() {
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
        // If any of user events is not active for idle-seconds when start timer.
        this.idleSubscription = this.idle$
            .pipe(bufferTime(5000), // Starting point of detecting of user's inactivity
        // Starting point of detecting of user's inactivity
        filter(arr => !arr.length && !this.isInactivityTimer), tap(() => this.isInactivityTimer = true), switchMap(() => interval(1000).pipe(takeUntil(merge(this.activityEvents$, timer(this.idle * 1000).pipe(tap(() => this.timerStart$.next(true))))), finalize(() => (this.isInactivityTimer = false)))))
            .subscribe();
        this.setupTimer(this.timeout);
        this.setupPing(this.ping);
    }
    /**
     * @return {?}
     */
    stopWatching() {
        this.stopTimer();
        if (this.idleSubscription) {
            this.idleSubscription.unsubscribe();
        }
    }
    /**
     * @return {?}
     */
    stopTimer() {
        this.timerStart$.next(false);
    }
    /**
     * @return {?}
     */
    resetTimer() {
        this.stopTimer();
        this.isTimeout = false;
    }
    /**
     * Return observable for timer's countdown number that emits after idle.
     * @return {?}
     */
    onTimerStart() {
        return this.timerStart$.pipe(distinctUntilChanged(), switchMap(start => (start ? this.timer$ : of(null))));
    }
    /**
     * Return observable for timeout is fired.
     * @return {?}
     */
    onTimeout() {
        return this.timeout$.pipe(filter(timeout => !!timeout), tap(() => this.isTimeout = true), map(() => true));
    }
    /**
     * @return {?}
     */
    getConfigValue() {
        return {
            idle: this.idle,
            timeout: this.timeout,
            ping: this.ping
        };
    }
    /**
     * Set config values.
     * @param {?} config
     * @return {?}
     */
    setConfigValues(config) {
        if (this.idleSubscription && !this.idleSubscription.closed) {
            console.error('Call stopWatching() before set config values');
            return;
        }
        if (config.idle) {
            this.idle = config.idle;
        }
        if (config.ping) {
            this.ping = config.ping;
        }
        if (config.timeout) {
            this.timeout = config.timeout;
        }
    }
    /**
     * Setup timer.
     *
     * Counts every seconds and return n+1 and fire timeout for last count.
     * @param {?} timeout Timeout in seconds.
     * @return {?}
     */
    setupTimer(timeout) {
        this.timer$ = interval(1000).pipe(take(timeout), map(() => 1), scan((acc, n) => acc + n), tap(count => {
            if (count === timeout) {
                this.timeout$.next(true);
            }
        }));
    }
    /**
     * Setup ping.
     *
     * Pings every ping-seconds only if is not timeout.
     * @param {?} ping
     * @return {?}
     */
    setupPing(ping) {
        this.ping$ = interval(ping * 1000).pipe(filter(() => !this.isTimeout));
    }
}
UserIdleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] },
];
/** @nocollapse */
UserIdleService.ctorParameters = () => [
    { type: UserIdleConfig, decorators: [{ type: Optional },] },
];
/** @nocollapse */ UserIdleService.ngInjectableDef = defineInjectable({ factory: function UserIdleService_Factory() { return new UserIdleService(inject(UserIdleConfig, 8)); }, token: UserIdleService, providedIn: "root" });

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
class UserIdleModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static forRoot(config) {
        return {
            ngModule: UserIdleModule,
            providers: [
                { provide: UserIdleConfig, useValue: config }
            ]
        };
    }
}
UserIdleModule.decorators = [
    { type: NgModule, args: [{
                imports: []
            },] },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { UserIdleService, UserIdleConfig, UserIdleModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci11c2VyLWlkbGUuanMubWFwIiwic291cmNlcyI6WyJuZzovL2FuZ3VsYXItdXNlci1pZGxlL2xpYi9hbmd1bGFyLXVzZXItaWRsZS5jb25maWcudHMiLCJuZzovL2FuZ3VsYXItdXNlci1pZGxlL2xpYi9hbmd1bGFyLXVzZXItaWRsZS5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLXVzZXItaWRsZS9saWIvYW5ndWxhci11c2VyLWlkbGUubW9kdWxlLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBVc2VySWRsZUNvbmZpZyB7XG4gIC8qKlxuICAgKiBJZGxlIHZhbHVlIGluIHNlY29uZHMuXG4gICAqL1xuICBpZGxlOiBudW1iZXI7XG4gIC8qKlxuICAgKiBUaW1lb3V0IHZhbHVlIGluIHNlY29uZHMuXG4gICAqL1xuICB0aW1lb3V0OiBudW1iZXI7XG4gIC8qKlxuICAgKiBQaW5nIHZhbHVlIGluIHNlY29uZHMuXG4gICAqL1xuICBwaW5nOiBudW1iZXI7XG59XG4iLCJpbXBvcnQgeyBJbmplY3RhYmxlLCBPcHRpb25hbCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcbiAgT2JzZXJ2YWJsZSxcbiAgU3ViamVjdCxcbiAgU3Vic2NyaXB0aW9uLFxuICBtZXJnZSxcbiAgZnJvbUV2ZW50LFxuICBmcm9tLFxuICBpbnRlcnZhbCxcbiAgdGltZXIsXG4gIG9mXG59IGZyb20gJ3J4anMnO1xuaW1wb3J0IHtcbiAgYnVmZmVyVGltZSxcbiAgZGlzdGluY3RVbnRpbENoYW5nZWQsXG4gIGZpbHRlcixcbiAgZmluYWxpemUsXG4gIG1hcCxcbiAgc2NhbixcbiAgc3dpdGNoTWFwLFxuICB0YWtlLFxuICB0YWtlVW50aWwsXG4gIHRhcFxufSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBVc2VySWRsZUNvbmZpZyB9IGZyb20gJy4vYW5ndWxhci11c2VyLWlkbGUuY29uZmlnJztcblxuLyoqXG4gKiBVc2VyJ3MgaWRsZSBzZXJ2aWNlLlxuICovXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290J1xufSlcbmV4cG9ydCBjbGFzcyBVc2VySWRsZVNlcnZpY2Uge1xuICBwaW5nJDogT2JzZXJ2YWJsZTxhbnk+O1xuXG4gIC8qKlxuICAgKiBFdmVudHMgdGhhdCBjYW4gaW50ZXJydXB0cyB1c2VyJ3MgaW5hY3Rpdml0eSB0aW1lci5cbiAgICovXG4gIHByb3RlY3RlZCBhY3Rpdml0eUV2ZW50cyQ6IE9ic2VydmFibGU8YW55PjtcblxuICBwcm90ZWN0ZWQgdGltZXJTdGFydCQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICBwcm90ZWN0ZWQgdGltZW91dCQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuICBwcm90ZWN0ZWQgaWRsZSQ6IE9ic2VydmFibGU8YW55PjtcbiAgcHJvdGVjdGVkIHRpbWVyJDogT2JzZXJ2YWJsZTxhbnk+O1xuICAvKipcbiAgICogSWRsZSB2YWx1ZSBpbiBzZWNvbmRzLlxuICAgKiBEZWZhdWx0IGVxdWFscyB0byAxMCBtaW51dGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGlkbGUgPSA2MDA7XG4gIC8qKlxuICAgKiBUaW1lb3V0IHZhbHVlIGluIHNlY29uZHMuXG4gICAqIERlZmF1bHQgZXF1YWxzIHRvIDUgbWludXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCB0aW1lb3V0ID0gMzAwO1xuICAvKipcbiAgICogUGluZyB2YWx1ZSBpbiBzZWNvbmRzLlxuICAgKiAqIERlZmF1bHQgZXF1YWxzIHRvIDIgbWludXRlcy5cbiAgICovXG4gIHByb3RlY3RlZCBwaW5nID0gMTIwO1xuICAvKipcbiAgICogVGltZW91dCBzdGF0dXMuXG4gICAqL1xuICBwcm90ZWN0ZWQgaXNUaW1lb3V0OiBib29sZWFuO1xuICAvKipcbiAgICogVGltZXIgb2YgdXNlcidzIGluYWN0aXZpdHkgaXMgaW4gcHJvZ3Jlc3MuXG4gICAqL1xuICBwcm90ZWN0ZWQgaXNJbmFjdGl2aXR5VGltZXI6IGJvb2xlYW47XG5cbiAgcHJvdGVjdGVkIGlkbGVTdWJzY3JpcHRpb246IFN1YnNjcmlwdGlvbjtcblxuICBjb25zdHJ1Y3RvcihAT3B0aW9uYWwoKSBjb25maWc6IFVzZXJJZGxlQ29uZmlnKSB7XG4gICAgaWYgKGNvbmZpZykge1xuICAgICAgdGhpcy5pZGxlID0gY29uZmlnLmlkbGU7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcbiAgICAgIHRoaXMucGluZyA9IGNvbmZpZy5waW5nO1xuICAgIH1cblxuICAgIHRoaXMuYWN0aXZpdHlFdmVudHMkID0gbWVyZ2UoXG4gICAgICBmcm9tRXZlbnQod2luZG93LCAnbW91c2Vtb3ZlJyksXG4gICAgICBmcm9tRXZlbnQod2luZG93LCAncmVzaXplJyksXG4gICAgICBmcm9tRXZlbnQoZG9jdW1lbnQsICdrZXlkb3duJylcbiAgICApO1xuXG4gICAgdGhpcy5pZGxlJCA9IGZyb20odGhpcy5hY3Rpdml0eUV2ZW50cyQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHdhdGNoaW5nIGZvciB1c2VyIGlkbGUgYW5kIHNldHVwIHRpbWVyIGFuZCBwaW5nLlxuICAgKi9cbiAgc3RhcnRXYXRjaGluZygpIHtcbiAgICBpZiAodGhpcy5pZGxlU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLmlkbGVTdWJzY3JpcHRpb24udW5zdWJzY3JpYmUoKTtcbiAgICB9XG5cbiAgICAvLyBJZiBhbnkgb2YgdXNlciBldmVudHMgaXMgbm90IGFjdGl2ZSBmb3IgaWRsZS1zZWNvbmRzIHdoZW4gc3RhcnQgdGltZXIuXG4gICAgdGhpcy5pZGxlU3Vic2NyaXB0aW9uID0gdGhpcy5pZGxlJFxuICAgICAgLnBpcGUoXG4gICAgICAgIGJ1ZmZlclRpbWUoNTAwMCksIC8vIFN0YXJ0aW5nIHBvaW50IG9mIGRldGVjdGluZyBvZiB1c2VyJ3MgaW5hY3Rpdml0eVxuICAgICAgICBmaWx0ZXIoYXJyID0+ICFhcnIubGVuZ3RoICYmICF0aGlzLmlzSW5hY3Rpdml0eVRpbWVyKSxcbiAgICAgICAgdGFwKCgpID0+IHRoaXMuaXNJbmFjdGl2aXR5VGltZXIgPSB0cnVlKSxcbiAgICAgICAgc3dpdGNoTWFwKCgpID0+IGludGVydmFsKDEwMDApLnBpcGUoXG4gICAgICAgICAgdGFrZVVudGlsKFxuICAgICAgICAgICAgbWVyZ2UoXG4gICAgICAgICAgICAgIHRoaXMuYWN0aXZpdHlFdmVudHMkLFxuICAgICAgICAgICAgICB0aW1lcih0aGlzLmlkbGUgKiAxMDAwKS5waXBlKFxuICAgICAgICAgICAgICAgIHRhcCgoKSA9PiB0aGlzLnRpbWVyU3RhcnQkLm5leHQodHJ1ZSkpXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApLFxuICAgICAgICAgIGZpbmFsaXplKCgpID0+ICh0aGlzLmlzSW5hY3Rpdml0eVRpbWVyID0gZmFsc2UpKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZSgpO1xuXG4gICAgdGhpcy5zZXR1cFRpbWVyKHRoaXMudGltZW91dCk7XG4gICAgdGhpcy5zZXR1cFBpbmcodGhpcy5waW5nKTtcbiAgfVxuXG4gIHN0b3BXYXRjaGluZygpIHtcbiAgICB0aGlzLnN0b3BUaW1lcigpO1xuICAgIGlmICh0aGlzLmlkbGVTdWJzY3JpcHRpb24pIHtcbiAgICAgIHRoaXMuaWRsZVN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgfVxuXG4gIHN0b3BUaW1lcigpIHtcbiAgICB0aGlzLnRpbWVyU3RhcnQkLm5leHQoZmFsc2UpO1xuICB9XG5cbiAgcmVzZXRUaW1lcigpIHtcbiAgICB0aGlzLnN0b3BUaW1lcigpO1xuICAgIHRoaXMuaXNUaW1lb3V0ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIG9ic2VydmFibGUgZm9yIHRpbWVyJ3MgY291bnRkb3duIG51bWJlciB0aGF0IGVtaXRzIGFmdGVyIGlkbGUuXG4gICAqL1xuICBvblRpbWVyU3RhcnQoKTogT2JzZXJ2YWJsZTxudW1iZXI+IHtcbiAgICByZXR1cm4gdGhpcy50aW1lclN0YXJ0JC5waXBlKFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgIHN3aXRjaE1hcChzdGFydCA9PiAoc3RhcnQgPyB0aGlzLnRpbWVyJCA6IG9mKG51bGwpKSlcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiBvYnNlcnZhYmxlIGZvciB0aW1lb3V0IGlzIGZpcmVkLlxuICAgKi9cbiAgb25UaW1lb3V0KCk6IE9ic2VydmFibGU8Ym9vbGVhbj4ge1xuICAgIHJldHVybiB0aGlzLnRpbWVvdXQkLnBpcGUoXG4gICAgICBmaWx0ZXIodGltZW91dCA9PiAhIXRpbWVvdXQpLFxuICAgICAgdGFwKCgpID0+IHRoaXMuaXNUaW1lb3V0ID0gdHJ1ZSksXG4gICAgICBtYXAoKCkgPT4gdHJ1ZSlcbiAgICApO1xuICB9XG5cbiAgZ2V0Q29uZmlnVmFsdWUoKTogVXNlcklkbGVDb25maWcge1xuICAgIHJldHVybiB7XG4gICAgICBpZGxlOiB0aGlzLmlkbGUsXG4gICAgICB0aW1lb3V0OiB0aGlzLnRpbWVvdXQsXG4gICAgICBwaW5nOiB0aGlzLnBpbmdcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjb25maWcgdmFsdWVzLlxuICAgKiBAcGFyYW0gY29uZmlnXG4gICAqL1xuICBzZXRDb25maWdWYWx1ZXMoY29uZmlnOiBVc2VySWRsZUNvbmZpZykge1xuICAgIGlmICh0aGlzLmlkbGVTdWJzY3JpcHRpb24gJiYgIXRoaXMuaWRsZVN1YnNjcmlwdGlvbi5jbG9zZWQpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0NhbGwgc3RvcFdhdGNoaW5nKCkgYmVmb3JlIHNldCBjb25maWcgdmFsdWVzJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbmZpZy5pZGxlKSB7XG4gICAgICB0aGlzLmlkbGUgPSBjb25maWcuaWRsZTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5waW5nKSB7XG4gICAgICB0aGlzLnBpbmcgPSBjb25maWcucGluZztcbiAgICB9XG4gICAgaWYgKGNvbmZpZy50aW1lb3V0KSB7XG4gICAgICB0aGlzLnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgdGltZXIuXG4gICAqXG4gICAqIENvdW50cyBldmVyeSBzZWNvbmRzIGFuZCByZXR1cm4gbisxIGFuZCBmaXJlIHRpbWVvdXQgZm9yIGxhc3QgY291bnQuXG4gICAqIEBwYXJhbSB0aW1lb3V0IFRpbWVvdXQgaW4gc2Vjb25kcy5cbiAgICovXG4gIHByb3RlY3RlZCBzZXR1cFRpbWVyKHRpbWVvdXQ6IG51bWJlcikge1xuICAgIHRoaXMudGltZXIkID0gaW50ZXJ2YWwoMTAwMCkucGlwZShcbiAgICAgIHRha2UodGltZW91dCksXG4gICAgICBtYXAoKCkgPT4gMSksXG4gICAgICBzY2FuKChhY2MsIG4pID0+IGFjYyArIG4pLFxuICAgICAgdGFwKGNvdW50ID0+IHtcbiAgICAgICAgaWYgKGNvdW50ID09PSB0aW1lb3V0KSB7XG4gICAgICAgICAgdGhpcy50aW1lb3V0JC5uZXh0KHRydWUpO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2V0dXAgcGluZy5cbiAgICpcbiAgICogUGluZ3MgZXZlcnkgcGluZy1zZWNvbmRzIG9ubHkgaWYgaXMgbm90IHRpbWVvdXQuXG4gICAqIEBwYXJhbSBwaW5nXG4gICAqL1xuICBwcm90ZWN0ZWQgc2V0dXBQaW5nKHBpbmc6IG51bWJlcikge1xuICAgIHRoaXMucGluZyQgPSBpbnRlcnZhbChwaW5nICogMTAwMCkucGlwZShcbiAgICAgIGZpbHRlcigoKSA9PiAhdGhpcy5pc1RpbWVvdXQpXG4gICAgKTtcbiAgfVxufVxuIiwiaW1wb3J0IHsgTW9kdWxlV2l0aFByb3ZpZGVycywgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFVzZXJJZGxlQ29uZmlnIH0gZnJvbSAnLi9hbmd1bGFyLXVzZXItaWRsZS5jb25maWcnO1xuXG5ATmdNb2R1bGUoe1xuICBpbXBvcnRzOiBbXVxufSlcbmV4cG9ydCBjbGFzcyBVc2VySWRsZU1vZHVsZSB7XG4gIHN0YXRpYyBmb3JSb290KGNvbmZpZzogVXNlcklkbGVDb25maWcpOiBNb2R1bGVXaXRoUHJvdmlkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmdNb2R1bGU6IFVzZXJJZGxlTW9kdWxlLFxuICAgICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHtwcm92aWRlOiBVc2VySWRsZUNvbmZpZywgdXNlVmFsdWU6IGNvbmZpZ31cbiAgICAgIF1cbiAgICB9O1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTtDQWFDOzs7Ozs7QUNiRDs7O0FBZ0NBOzs7O0lBc0NFLFlBQXdCOzJCQTlCQSxJQUFJLE9BQU8sRUFBVzt3QkFDekIsSUFBSSxPQUFPLEVBQVc7Ozs7O29CQU8xQixHQUFHOzs7Ozt1QkFLQSxHQUFHOzs7OztvQkFLTixHQUFHO1FBYWxCLElBQUksTUFBTSxFQUFFO1lBQ1YsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDO1lBQ3hCLElBQUksQ0FBQyxPQUFPLEdBQUcsTUFBTSxDQUFDLE9BQU8sQ0FBQztZQUM5QixJQUFJLENBQUMsSUFBSSxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUM7U0FDekI7UUFFRCxJQUFJLENBQUMsZUFBZSxHQUFHLEtBQUssQ0FDMUIsU0FBUyxDQUFDLE1BQU0sRUFBRSxXQUFXLENBQUMsRUFDOUIsU0FBUyxDQUFDLE1BQU0sRUFBRSxRQUFRLENBQUMsRUFDM0IsU0FBUyxDQUFDLFFBQVEsRUFBRSxTQUFTLENBQUMsQ0FDL0IsQ0FBQztRQUVGLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksQ0FBQyxlQUFlLENBQUMsQ0FBQztLQUN6Qzs7Ozs7SUFLRCxhQUFhO1FBQ1gsSUFBSSxJQUFJLENB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